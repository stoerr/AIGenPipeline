<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FileLookupHelper.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">AIGenPipeline Command Line Tool</a> &gt; <a href="../index.html" class="el_bundle">aigenpipeline-framework</a> &gt; <a href="index.source.html" class="el_package">net.stoerr.ai.aigenpipeline.framework.task</a> &gt; <span class="el_source">FileLookupHelper.java</span></div><h1>FileLookupHelper.java</h1><pre class="source lang-java linenums">package net.stoerr.ai.aigenpipeline.framework.task;

import java.io.File;
import java.io.IOException;
import java.nio.charset.MalformedInputException;
import java.nio.file.FileSystem;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Makes it easy to find files to process with {@link AIGenerationTask} etc.
 */
public class FileLookupHelper {

<span class="nc" id="L30">    protected static final Logger LOG = Logger.getLogger(FileLookupHelper.class.getName());</span>

    public static final String HTML_PATTERN = &quot;.*\\.html&quot;;

    /**
     * A pattern matching a prefix of a file name that ends with a / and has no meta characters of the
     * {@link java.nio.file.FileSystem#getPathMatcher(String)} in it.
     */
<span class="nc" id="L38">    protected static final Pattern NOMETAPREFIXPATTERN = Pattern.compile(&quot;^/?([^/*?{}\\[\\]]+/)+&quot;);</span>

    /**
     * The maximum filesize we search in.
     */
    protected static final int FILE_MAXSIZE = 50 * 1024;

    /**
     * Pattern matching file names of files which have binary content (*.jpg, *.gif, *.jar etc.), which we ignore in the search.
     */
<span class="nc" id="L48">    protected static final Pattern BINARYFILEPATTERN = Pattern.compile(</span>
            &quot;.*\\.(jpg|gif|png|[jwet]ar|class|zip|gz|tgz|pdf|doc|xls|ppt|docx|xlsx|pptx|odt|ods)&quot;);

    protected final File directory;

<span class="nc" id="L53">    protected FileLookupHelper(String path) {</span>
        try {
<span class="nc" id="L55">            directory = new File(path).getAbsoluteFile().getCanonicalFile();</span>
<span class="nc" id="L56">        } catch (IOException e) {</span>
<span class="nc" id="L57">            throw new IllegalStateException(&quot;Path &quot; + path + &quot; does not exist&quot;, e);</span>
<span class="nc" id="L58">        }</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (!directory.isDirectory()) {</span>
<span class="nc" id="L60">            throw new IllegalStateException(&quot;Directory &quot; + directory + &quot; does not exist&quot;);</span>
        }
<span class="nc" id="L62">    }</span>

    public static FileLookupHelper fromPath(String... relativePaths) {
<span class="nc" id="L65">        StringBuilder path = new StringBuilder();</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        for (String relativePath : relativePaths) {</span>
<span class="nc" id="L67">            path.append(relativePath).append(&quot;/&quot;);</span>
        }
<span class="nc" id="L69">        return new FileLookupHelper(path.toString());</span>
    }

    /**
     * Make repository from environment variable.
     */
    public static FileLookupHelper fromEnv(@Nonnull String envVar, @Nullable String relativePath) {
<span class="nc" id="L76">        String path = System.getenv(envVar);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (path == null) {</span>
<span class="nc" id="L78">            throw new IllegalStateException(&quot;Environment variable &quot; + envVar + &quot; not set&quot;);</span>
        }
<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (relativePath != null) {</span>
<span class="nc" id="L81">            path = path + File.pathSeparator + relativePath;</span>
        }
<span class="nc" id="L83">        return new FileLookupHelper(path);</span>
    }

    /**
     * File relative to repository root - that doesn't need to exist (might be output file).
     */
    public File file(String relpath) {
<span class="nc" id="L90">        return new File(directory, relpath);</span>
    }

    /**
     * Files in a directory, matching an ant style pattern - more specifically like
     * {@link java.nio.file.FileSystem#getPathMatcher(String)} glob patterns (without &quot;glob:&quot; prefix).
     *
     * @param relpathDirectory the directory relative to the repository root
     * @param filePathPattern  the file pattern to match, see {@link java.nio.file.FileSystem#getPathMatcher(String)} glob pattern
     * @param recursive        whether to recurse into subdirectories
     * @return a list of files
     * @see java.nio.file.FileSystem#getPathMatcher(String)
     */
    @Nonnull
    public List&lt;File&gt; files(@Nonnull String relpathDirectory, @Nullable String filePathPattern, boolean recursive) {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (filePathPattern != null) {</span>
<span class="nc" id="L106">            Matcher fixedPrefixMatcher = NOMETAPREFIXPATTERN.matcher(filePathPattern);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (fixedPrefixMatcher.find()) {</span>
<span class="nc" id="L108">                String prefix = fixedPrefixMatcher.group();</span>
<span class="nc" id="L109">                relpathDirectory = Path.of(relpathDirectory).resolve(prefix).normalize().toString();</span>
<span class="nc" id="L110">                filePathPattern = filePathPattern.substring(prefix.length());</span>
            }
        }

<span class="nc" id="L114">        Path dir = directory.toPath().resolve(relpathDirectory).normalize();</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (!dir.toFile().isDirectory()) {</span>
<span class="nc" id="L116">            throw new IllegalStateException(&quot;Directory &quot; + dir + &quot; does not exist&quot;);</span>
        }
<span class="nc bnc" id="L118" title="All 4 branches missed.">        PathMatcher pathMatcher = null != filePathPattern &amp;&amp; !filePathPattern.isEmpty() ?</span>
<span class="nc" id="L119">                dir.getFileSystem().getPathMatcher(&quot;glob:&quot; + filePathPattern) : null;</span>
<span class="nc" id="L120">        List&lt;File&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (!recursive) {</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">            File[] files = dir.toFile().listFiles(file -&gt; pathMatcher == null || pathMatcher.matches(file.toPath())</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                    || pathMatcher.matches(dir.relativize(file.toPath())));</span>
<span class="nc" id="L124">            Arrays.stream(Objects.requireNonNull(files, dir.toString()))</span>
<span class="nc" id="L125">                    .filter(File::isFile).forEach(result::add);</span>
<span class="nc" id="L126">        } else {</span>
            try {
<span class="nc" id="L128">                Files.walkFileTree(dir, new SimpleFileVisitor&lt;&gt;() {</span>
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
<span class="nc" id="L131">                        Path relativePath = dir.relativize(file);</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">                        if (Files.isRegularFile(file) &amp;&amp;</span>
<span class="nc bnc" id="L133" title="All 4 branches missed.">                                (pathMatcher == null || pathMatcher.matches(relativePath) || pathMatcher.matches(file))) {</span>
<span class="nc" id="L134">                            result.add(file.toFile());</span>
                        }
<span class="nc" id="L136">                        return super.visitFile(file, attrs);</span>
                    }
                });
<span class="nc" id="L139">            } catch (IOException e) {</span>
<span class="nc" id="L140">                LOG.severe(&quot;for &quot; + dir + &quot;:&quot; + e);</span>
<span class="nc" id="L141">            }</span>
        }
<span class="nc" id="L143">        return result;</span>
    }

    /**
     * All files matching a filePathRegex that contain a pattern.
     *
     * @param relpathDirectory the directory relative to the repository root
     * @param filePathPattern  the file pattern to match
     * @param pattern          the regex to look for in the file content
     * @param recursive        whether to recurse into subdirectories
     * @return a list of files
     */
    @Nonnull
    public List&lt;File&gt; filesContaining(@Nonnull String relpathDirectory, @Nonnull String filePathPattern, @Nonnull Pattern pattern, boolean recursive) {
<span class="nc" id="L157">        List&lt;File&gt; candidates = files(relpathDirectory, filePathPattern, recursive);</span>
<span class="nc" id="L158">        List&lt;File&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (File file : candidates) {</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">            if (file.length() &gt; FILE_MAXSIZE || BINARYFILEPATTERN.matcher(file.getName()).matches()) {</span>
<span class="nc" id="L161">                continue;</span>
            }
            try {
<span class="nc" id="L164">                String content = Files.readString(file.toPath());</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                if (pattern.matcher(content).find()) {</span>
<span class="nc" id="L166">                    result.add(file);</span>
                }
<span class="nc" id="L168">            } catch (MalformedInputException e) { // skip binary file</span>
                // ignore
<span class="nc" id="L170">            } catch (IOException e) {</span>
<span class="nc" id="L171">                LOG.severe(&quot;for &quot; + file + &quot;:&quot; + e);</span>
<span class="nc" id="L172">            }</span>
<span class="nc" id="L173">        }</span>
<span class="nc" id="L174">        return result;</span>
    }

    /**
     * File from full java class name.
     */
    @Nonnull
    public File javaFile(@Nonnull String fullName) {
<span class="nc" id="L182">        return new File(directory, fullName.replaceAll(&quot;[.]&quot;, &quot;/&quot;) + &quot;.java&quot;);</span>
    }

    /**
     * File for documenting a full java class name.
     */
    @Nonnull
    public File javaMdFile(@Nonnull String fullName) {
<span class="nc" id="L190">        return new File(directory, fullName.replaceAll(&quot;[.]&quot;, &quot;/&quot;) + &quot;.md&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>