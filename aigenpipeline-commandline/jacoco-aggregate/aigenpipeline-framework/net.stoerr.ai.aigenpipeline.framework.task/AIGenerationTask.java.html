<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AIGenerationTask.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">AIGenPipeline Command Line Tool</a> &gt; <a href="../index.html" class="el_bundle">aigenpipeline-framework</a> &gt; <a href="index.source.html" class="el_package">net.stoerr.ai.aigenpipeline.framework.task</a> &gt; <span class="el_source">AIGenerationTask.java</span></div><h1>AIGenerationTask.java</h1><pre class="source lang-java linenums">package net.stoerr.ai.aigenpipeline.framework.task;

import static java.util.Objects.requireNonNull;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import net.stoerr.ai.aigenpipeline.framework.chat.AIChatBuilder;

/**
 * We support the generation of files using an AI, specifically ChatGPT. A generation task can have several input files.
 * Some of them can be prompt files with task descriptions, and some of them source files to be processed. The output
 * of each task is one text file. A complex task can have several steps leading to several intermediate files.
 * &lt;p&gt;
 * Since ChatGPT is not particularily fast not free and the generation results have to be manually checked, this is
 * heavily cached.
 * Into each output file we write the versions of all the input files from which it was generated into a comment.
 * When the tasks are run, we compare the
 * versions of all the input files with the versions recorded in the comment, and only regenerate the output file if
 * the versions have changed. An input file can have a version comment that explicitly states the version, or we take the
 * an abbreviated SHA256 hash of the input file as version. It is possible to explicitly state the versions in
 * version comments in the input files to avoid regenerating all files if minor details e.g. in a prompt file are
 * changed - only when the prompt file version comment is changed everything is regenerated.
 * &lt;p&gt;
 * A version comment can e.g. look like this:
 * &lt;p&gt;
 * // AIGenVersion(ourversion, inputfile1@version1, inputfile2@version2, ...)
 * &lt;p&gt;
 * where ourversion and version1 and version2 are hashes. ourversion is the hash of the original output of the AI.
 * The comment syntax (in this case //) is ignored - we just look for the AIGenVersion via regex.
 * &lt;p&gt;
 * Normally the intermediate and final results should be checked in with Git. That ensures manual checks when
 * they are regenerated, and minimizes regeneration.
 */
<span class="nc" id="L52">public class AIGenerationTask implements Cloneable {</span>

<span class="nc" id="L54">    protected static final Logger LOG = Logger.getLogger(AIGenerationTask.class.getName());</span>

    /**
     * A marker that can be inserted by the AI when something is wrong / unclear. We will make sure the user
     * sees that by aborting.
     */
    public static final String FIXME = &quot;FIXME&quot;;

    /**
     * A pattern that matches the license header, which we want to remove to avoid clutter.
     */
<span class="nc" id="L65">    protected static final Pattern PATTERN_LICENCE =</span>
<span class="nc" id="L66">            Pattern.compile(&quot;\\A&lt;!--(?s).*?Copyright.*?Adobe.*?Licensed under.*?--&gt;&quot;);</span>


<span class="nc" id="L69">    protected List&lt;File&gt; inputFiles = new ArrayList&lt;&gt;();</span>
    protected File outputFile;

    /**
     * The actual prompt created from prompt files and parameters.
     */
    protected String prompt;
<span class="nc" id="L76">    protected List&lt;File&gt; promptFiles = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L77">    protected Map&lt;String, String&gt; placeholdersAndValues = new LinkedHashMap&lt;&gt;();</span>

    protected String systemMessage;
    protected File systemMessageFile;
    protected boolean force;
    protected Integer maxTokens;

    /**
     * Creates a deep copy of the task.
     */
    public AIGenerationTask copy() {
        try {
<span class="nc" id="L89">            AIGenerationTask copy = (AIGenerationTask) super.clone();</span>
<span class="nc" id="L90">            copy.inputFiles = new ArrayList&lt;&gt;(inputFiles);</span>
<span class="nc" id="L91">            return copy;</span>
<span class="nc" id="L92">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L93">            throw new IllegalStateException(&quot;Bug - impossible.&quot;, e);</span>
        }
    }

    /**
     * We override this to allow cloning for use with the {@link #copy()} method, but deliberately leave it protected
     * since the use of {@link #copy()} is intended.
     *
     * @deprecated use {@link #copy()}
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
<span class="nc" id="L105">        return super.clone();</span>
    }

    public AIGenerationTask maxTokens(Integer maxTokens) {
<span class="nc" id="L109">        this.maxTokens = maxTokens;</span>
<span class="nc" id="L110">        return this;</span>
    }

    public AIGenerationTask addOptionalInputFile(@Nullable File file) {
<span class="nc bnc" id="L114" title="All 4 branches missed.">        if (file != null &amp;&amp; file.exists()) {</span>
<span class="nc" id="L115">            inputFiles.add(file);</span>
        } else {
<span class="nc" id="L117">            LOG.fine(() -&gt; &quot;Optional file not there: &quot; + file);</span>
        }
<span class="nc" id="L119">        return this;</span>
    }

    public AIGenerationTask addInputFiles(List&lt;File&gt; files) {
<span class="nc bnc" id="L123" title="All 2 branches missed.">        for (File file : files) {</span>
<span class="nc" id="L124">            addInputFile(file);</span>
<span class="nc" id="L125">        }</span>
<span class="nc" id="L126">        return this;</span>
    }

    public AIGenerationTask addInputFile(File file) {
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L131">            throw new IllegalArgumentException(&quot;File &quot; + file + &quot; does not exist&quot;);</span>
        }
<span class="nc" id="L133">        inputFiles.add(file);</span>
<span class="nc" id="L134">        return this;</span>
    }

    public AIGenerationTask setOutputFile(@Nonnull File file) {
<span class="nc" id="L138">        requireNonNull(file, &quot;File must not be null&quot;);</span>
<span class="nc" id="L139">        outputFile = file;</span>
<span class="nc" id="L140">        return this;</span>
    }

    protected String embedComment(String content, String comment) {
        String result;
<span class="nc" id="L145">        String extension = outputFile.getName().substring(outputFile.getName().lastIndexOf('.') + 1);</span>
<span class="nc bnc" id="L146" title="All 6 branches missed.">        switch (extension) {</span>
            case &quot;java&quot;:
            case &quot;txt&quot;: // there is no real comment syntax for txt, but that might be obvious to a human reader
<span class="nc" id="L149">                result = &quot;// &quot; + comment + &quot;\n\n&quot; + content;</span>
<span class="nc" id="L150">                break;</span>
            case &quot;html&quot;:
            case &quot;htm&quot;:
            case &quot;xml&quot;:
            case &quot;jsp&quot;:
<span class="nc" id="L155">                result = content + &quot;\n\n&lt;!-- &quot; + comment + &quot; --&gt;\n&quot;;</span>
<span class="nc" id="L156">                break;</span>
            case &quot;css&quot;:
            case &quot;js&quot;:
            case &quot;json&quot;: // that's a problem, no comment syntax. Let's see whether this makes sense.
<span class="nc" id="L160">                result = &quot;/* &quot; + comment + &quot; */\n\n&quot; + content;</span>
<span class="nc" id="L161">                break;</span>
            case &quot;md&quot;:
<span class="nc" id="L163">                result = &quot;&lt;!-- &quot; + comment + &quot; --&gt;\n\n&quot; + content;</span>
<span class="nc" id="L164">                break;</span>
            case &quot;sh&quot;:
            case &quot;yaml&quot;:
<span class="nc" id="L167">                result = &quot;# &quot; + comment + &quot;\n&quot; + content;</span>
<span class="nc" id="L168">                break;</span>
            default:
<span class="nc" id="L170">                result = &quot;/* &quot; + comment + &quot; */\n\n&quot; + content;</span>
                break;
        }
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (!result.endsWith(&quot;\n&quot;)) {</span>
<span class="nc" id="L174">            result += &quot;\n&quot;;</span>
        }
<span class="nc" id="L176">        return result;</span>
    }

    public boolean hasToBeRun() {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (!outputFile.exists()) {</span>
<span class="nc" id="L181">            return true;</span>
        }
<span class="nc" id="L183">        AIVersionMarker outputVersionMarker = getRecordedOutputVersionMarker();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (outputVersionMarker == null) {</span>
<span class="nc" id="L185">            return true;</span>
        }
<span class="nc" id="L187">        List&lt;String&gt; inputVersions = calculateAllInputsMarkers();</span>
<span class="nc" id="L188">        List&lt;String&gt; oldInputVersions = outputVersionMarker.getInputVersions();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        return !new HashSet&lt;Object&gt;(inputVersions).equals(new HashSet&lt;Object&gt;(oldInputVersions));</span>
    }

    @Nonnull
    protected List&lt;String&gt; calculateAllInputsMarkers() {
<span class="nc" id="L194">        List&lt;String&gt; allInputsMarkers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (systemMessageFile != null) {</span>
<span class="nc" id="L196">            allInputsMarkers.add(determineFileVersionMarker(systemMessageFile));</span>
        }
<span class="nc" id="L198">        promptFiles.stream()</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                .filter(f -&gt; !f.getAbsolutePath().equals(outputFile.getAbsolutePath()))</span>
<span class="nc" id="L200">                .forEach(file -&gt; allInputsMarkers.add(determineFileVersionMarker(file)));</span>
<span class="nc" id="L201">        inputFiles.stream()</span>
                // don't introduce circular dependencies when updating an existing output file:
<span class="nc bnc" id="L203" title="All 2 branches missed.">                .filter(f -&gt; !f.getAbsolutePath().equals(outputFile.getAbsolutePath()))</span>
<span class="nc" id="L204">                .forEach(file -&gt; allInputsMarkers.add(determineFileVersionMarker(file)));</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (!placeholdersAndValues.isEmpty()) {</span>
<span class="nc" id="L206">            allInputsMarkers.add(&quot;parms-&quot; + shaHash(placeholdersAndValues.toString()));</span>
        }
<span class="nc" id="L208">        return allInputsMarkers;</span>
    }

    protected String determineFileVersionMarker(@Nonnull File file) {
<span class="nc" id="L212">        String content = getFileContent(file);</span>
<span class="nc" id="L213">        requireNonNull(content, &quot;Could not read file &quot; + file);</span>
<span class="nc" id="L214">        AIVersionMarker aiVersionMarker = AIVersionMarker.find(content);</span>
        String version;
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (aiVersionMarker != null) {</span>
<span class="nc" id="L217">            version = aiVersionMarker.getOurVersion();</span>
        } else {
<span class="nc" id="L219">            version = shaHash(content);</span>
        }
<span class="nc" id="L221">        return file.getName() + &quot;-&quot; + version;</span>
    }

    protected String shaHash(String content) {
<span class="nc" id="L225">        String condensedWhitespace = content.replaceAll(&quot;\\s+&quot;, &quot; &quot;);</span>
        try {
<span class="nc" id="L227">            MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="nc" id="L228">            byte[] hash = digest.digest(condensedWhitespace.getBytes(StandardCharsets.UTF_8));</span>
            // turn first 4 bytes into hex number
<span class="nc" id="L230">            long hashNumber = ((hash[3] * 256L + hash[2]) * 256L + hash[1]) * 256L + hash[0];</span>
<span class="nc" id="L231">            String hexString = &quot;00000000&quot; + Long.toHexString(Math.abs(hashNumber));</span>
<span class="nc" id="L232">            return hexString.substring(hexString.length() - 8);</span>
<span class="nc" id="L233">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L234">            throw new IllegalStateException(&quot;SHA256 not available&quot;, e);</span>
        }
    }

    /**
     * Version of current output file.
     */
    protected AIVersionMarker getRecordedOutputVersionMarker() {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (!outputFile.exists()) {</span>
<span class="nc" id="L243">            return null;</span>
        }
<span class="nc" id="L245">        String content = getFileContent(outputFile);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (content == null) {</span>
<span class="nc" id="L247">            return null;</span>
        }
<span class="nc" id="L249">        AIVersionMarker aiVersionMarker = AIVersionMarker.find(content);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (aiVersionMarker == null) {</span>
<span class="nc" id="L251">            throw new IllegalStateException(&quot;Could not find version marker in &quot; + outputFile);</span>
        }
<span class="nc" id="L253">        return aiVersionMarker;</span>
    }

    /**
     * The actual prompt to be executed. The prompt file content can contain placeholders that are replaced by the values given: placeholdersAndValues contain alternatingly placeholder names and values for them.
     *
     * @return this
     */
    public AIGenerationTask addPrompt(@Nonnull File promptFile, String... placeholdersAndValues) {
<span class="nc" id="L262">        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (int i = 0; i &lt; placeholdersAndValues.length; i += 2) {</span>
<span class="nc" id="L264">            map.put(placeholdersAndValues[i], placeholdersAndValues[i + 1]);</span>
        }
<span class="nc" id="L266">        return addPrompt(promptFile, map);</span>
    }

    /**
     * The actual prompt to be executed. The prompt file content can contain placeholders that are replaced by the values given.
     *
     * @return this
     */
    public AIGenerationTask addPrompt(@Nonnull File promptFile, Map&lt;String, String&gt; placeholdersAndValues) {
<span class="nc" id="L275">        String fileContent = getFileContent(promptFile);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (fileContent == null) {</span>
<span class="nc" id="L277">            throw new IllegalArgumentException(&quot;Could not read prompt file &quot; + promptFile);</span>
        }
<span class="nc" id="L279">        String newPrompt = unclutter(fileContent);</span>
<span class="nc" id="L280">        requireNonNull(newPrompt, &quot;Could not read prompt file &quot; + promptFile);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : placeholdersAndValues.entrySet()) {</span>
<span class="nc" id="L282">            newPrompt = newPrompt.replace(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L283">        }</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (this.prompt == null) {</span>
<span class="nc" id="L285">            this.prompt = newPrompt;</span>
        } else {
<span class="nc" id="L287">            this.prompt += &quot;\n\n&quot; + newPrompt;</span>
        }
<span class="nc" id="L289">        this.promptFiles.add(promptFile);</span>
<span class="nc" id="L290">        this.placeholdersAndValues.putAll(placeholdersAndValues);</span>
<span class="nc" id="L291">        return this;</span>
    }

    protected String getFileContent(@Nonnull File file) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L296">            return null;</span>
        }
        try {
<span class="nc" id="L299">            return Files.readString(file.toPath(), StandardCharsets.UTF_8);</span>
<span class="nc" id="L300">        } catch (IOException e) {</span>
<span class="nc" id="L301">            throw new IllegalArgumentException(&quot;Error reading file &quot; + file, e);</span>
        }
    }

    /* Remove some clutter that is not relevant and might even confuse the AI */
    protected static String unclutter(String content) {
<span class="nc" id="L307">        Matcher matcher = PATTERN_LICENCE.matcher(content);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (matcher.find()) {</span>
<span class="nc" id="L309">            content = matcher.replaceFirst(&quot;&quot;);</span>
        }
<span class="nc" id="L311">        matcher = AIVersionMarker.VERSION_MARKER_PATTERN.matcher(content);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (matcher.find()) {</span>
<span class="nc" id="L313">            content = matcher.replaceFirst(&quot;&quot;);</span>
        }
<span class="nc" id="L315">        return content;</span>
    }

    public AIGenerationTask setSystemMessage(@Nonnull File systemMessageFile) {
<span class="nc" id="L319">        String newSystemMessage = unclutter(getFileContent(systemMessageFile));</span>
<span class="nc" id="L320">        requireNonNull(newSystemMessage, &quot;Could not read system message file &quot; + systemMessageFile);</span>
<span class="nc" id="L321">        this.systemMessage = newSystemMessage;</span>
<span class="nc" id="L322">        this.systemMessageFile = systemMessageFile;</span>
<span class="nc" id="L323">        return this;</span>
    }

    protected String relativePath(@Nullable File file, @Nonnull File rootDirectory) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (file == null) {</span>
<span class="nc" id="L328">            return null;</span>
        }
<span class="nc" id="L330">        requireNonNull(rootDirectory, &quot;Root directory must not be null&quot;);</span>
<span class="nc" id="L331">        String rootPath = null;</span>
        try {
<span class="nc" id="L333">            rootPath = rootDirectory.getAbsoluteFile().getCanonicalFile().getAbsolutePath();</span>
<span class="nc" id="L334">            String filePath = file.getAbsoluteFile().getCanonicalFile().getAbsolutePath();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (!filePath.startsWith(rootPath)) {</span>
<span class="nc" id="L336">                throw new IllegalArgumentException(&quot;File &quot; + file + &quot; is not in root directory &quot; + rootDirectory);</span>
            }
<span class="nc" id="L338">            return filePath.substring(rootPath.length() + 1);</span>
<span class="nc" id="L339">        } catch (IOException e) {</span>
<span class="nc" id="L340">            throw new IllegalArgumentException(&quot;Error getting canonical path for &quot; + rootDirectory + &quot; or &quot; + file, e);</span>
        }
    }

    /**
     * Execute the task if necessary. If the output file is already there and up to date, nothing is done.
     */
    public AIGenerationTask execute(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory) {
<span class="nc" id="L348">        String outputRelPath = relativePath(this.outputFile, rootDirectory);</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">        if (!force &amp;&amp; !hasToBeRun()) {</span>
<span class="nc" id="L350">            LOG.info(() -&gt; &quot;Task does not have to be run for: &quot; + outputRelPath);</span>
<span class="nc" id="L351">            return this;</span>
        }
<span class="nc" id="L353">        AIChatBuilder chat = makeChatBuilder(chatBuilderFactory, rootDirectory, outputRelPath);</span>
<span class="nc" id="L354">        String result = chat.execute();</span>
<span class="nc" id="L355">        LOG.fine(() -&gt; &quot;Result for task execution for: &quot; + outputRelPath + &quot;\n&quot; + result);</span>
<span class="nc" id="L356">        String outputVersion = shaHash(result);</span>
<span class="nc" id="L357">        String versionComment = new AIVersionMarker(outputVersion, calculateAllInputsMarkers()).toString();</span>
<span class="nc" id="L358">        String withVersionComment = embedComment(result, versionComment);</span>

        try {
<span class="nc" id="L361">            Files.write(outputFile.toPath(), withVersionComment.getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L362">        } catch (IOException e) {</span>
<span class="nc" id="L363">            throw new IllegalStateException(&quot;Error writing file &quot; + outputFile, e);</span>
<span class="nc" id="L364">        }</span>
<span class="nc" id="L365">        LOG.info(&quot;Wrote file file://&quot; + outputFile.getAbsolutePath());</span>
        // We check that after writing since that likely makes it easier to check.
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (result.contains(FIXME)) {</span>
<span class="nc" id="L368">            throw new IllegalStateException(&quot;AI returned FIXME for &quot; + outputRelPath + &quot; :\n&quot; + result);</span>
        }
<span class="nc" id="L370">        return this;</span>
    }

    /**
     * For debugging purposes: returns the JSON that would be sent to the AI.
     */
    public String toJson(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory) {
<span class="nc" id="L377">        String outputRelPath = relativePath(this.outputFile, rootDirectory);</span>
<span class="nc" id="L378">        return makeChatBuilder(chatBuilderFactory, rootDirectory, outputRelPath).toJson();</span>
    }

    @Nonnull
    protected AIChatBuilder makeChatBuilder(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory, String outputRelPath) {
<span class="nc" id="L383">        requireNonNull(outputFile, &quot;No writeable output file given! &quot; + outputFile);</span>
<span class="nc bnc" id="L384" title="All 4 branches missed.">        if (null != outputFile.getParentFile() &amp;&amp; !outputFile.getParentFile().isDirectory()) {</span>
<span class="nc" id="L385">            outputFile.getParentFile().mkdirs();</span>
        }
<span class="nc bnc" id="L387" title="All 4 branches missed.">        if (outputFile.exists() &amp;&amp; !outputFile.canWrite()) {</span>
<span class="nc" id="L388">            throw new IllegalArgumentException(&quot;No writeable output file given! &quot; + outputFile);</span>
        }
<span class="nc bnc" id="L390" title="All 4 branches missed.">        if (prompt == null || prompt.isBlank()) {</span>
<span class="nc" id="L391">            throw new IllegalArgumentException(&quot;No prompt given!&quot;);</span>
        }
<span class="nc" id="L393">        AIChatBuilder chat = chatBuilderFactory.get();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (maxTokens != null) {</span>
<span class="nc" id="L395">            chat.maxTokens(maxTokens);</span>
        }
<span class="nc bnc" id="L397" title="All 4 branches missed.">        if (systemMessage != null &amp;&amp; !systemMessage.isBlank()) {</span>
<span class="nc" id="L398">            chat.systemMsg(systemMessage);</span>
        } else {
<span class="nc" id="L400">            try (InputStream defaultprompt = AIGenerationTask.class.getResourceAsStream(&quot;/defaultsystemprompt.txt&quot;)) {</span>
<span class="nc" id="L401">                String defaultSysPrompt = new String(defaultprompt.readAllBytes(), StandardCharsets.UTF_8);</span>
<span class="nc" id="L402">                chat.systemMsg(defaultSysPrompt);</span>
<span class="nc" id="L403">            } catch (IOException e) {</span>
<span class="nc" id="L404">                throw new IllegalStateException(&quot;Error reading default system message&quot;, e);</span>
<span class="nc" id="L405">            }</span>
        }
<span class="nc" id="L407">        inputFiles.forEach(file -&gt; {</span>
            // &quot;Put it into the AI's mouth&quot; pattern https://www.stoerr.net/blog/aimouth
<span class="nc" id="L409">            chat.userMsg(&quot;Retrieve the content of the input file &quot; + relativePath(file, rootDirectory));</span>
<span class="nc" id="L410">            chat.assistantMsg(unclutter(getFileContent(file)));</span>
<span class="nc" id="L411">        });</span>
<span class="nc" id="L412">        chat.userMsg(prompt);</span>
<span class="nc" id="L413">        LOG.fine(() -&gt; &quot;Executing chat for: &quot; + outputRelPath + &quot;\n&quot; + chat.toJson());</span>
<span class="nc" id="L414">        return chat;</span>
    }

    /**
     * Ask a question about the previous task execution. We assume it was previously run ({@link #hasToBeRun()} == false),
     * add the result of the previous execution to the chat, and ask the AI the given question about it.
     * This can be used e.g. to see why the AI did something, or in the process of improving the prompt, etc.
     *
     * @return the answer of the AI - not written to a file!
     */
    public String explain(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory, @Nonnull String question) {
<span class="nc" id="L425">        String outputRelPath = relativePath(this.outputFile, rootDirectory);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (hasToBeRun()) { // that's not strictly necessary, but if not that's a likely mistake</span>
<span class="nc" id="L427">            throw new IllegalStateException(&quot;Task has to be already run for: &quot; + outputRelPath);</span>
        }
<span class="nc" id="L429">        AIChatBuilder chat = makeChatBuilder(chatBuilderFactory, rootDirectory, outputRelPath);</span>
<span class="nc" id="L430">        String previousOutput = unclutter(getFileContent(outputFile));</span>
<span class="nc" id="L431">        requireNonNull(previousOutput, &quot;Could not read any content from file &quot; + outputFile);</span>
<span class="nc" id="L432">        chat.assistantMsg(previousOutput);</span>
<span class="nc" id="L433">        chat.userMsg(question);</span>
<span class="nc" id="L434">        String result = chat.execute();</span>
<span class="nc" id="L435">        LOG.info(() -&gt; &quot;Explanation result for &quot; + outputRelPath + &quot; with question &quot; + question + &quot; is:\n&quot; + result);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (result.contains(FIXME)) {</span>
<span class="nc" id="L437">            throw new IllegalStateException(&quot;AI returned FIXME for &quot; + outputRelPath + &quot; :\n&quot; + result);</span>
        }
<span class="nc" id="L439">        return result;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L444">        return &quot;AIGenerationTask{&quot; + &quot;inputFiles=&quot; + inputFiles +</span>
                &quot;, outputFile=&quot; + outputFile +
                &quot;, systemMessageFile=&quot; + systemMessageFile +
                &quot;, systemMessage='&quot; + systemMessage + '\'' +
                &quot;, promptFiles=&quot; + promptFiles +
                &quot;, placeholdersAndValues=&quot; + placeholdersAndValues +
                &quot;, prompt='&quot; + prompt + '\'' +
                '}';
    }

    /**
     * If true the generation will be run even if not {@link #hasToBeRun()}.
     */
    public void force(boolean force) {
<span class="nc" id="L458">        this.force = force;</span>
<span class="nc" id="L459">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>