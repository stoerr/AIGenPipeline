<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AIGenerationTask.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">AIGenPipeline Command Line Tool</a> &gt; <a href="../index.html" class="el_bundle">aigenpipeline-framework</a> &gt; <a href="index.source.html" class="el_package">net.stoerr.ai.aigenpipeline.framework.task</a> &gt; <span class="el_source">AIGenerationTask.java</span></div><h1>AIGenerationTask.java</h1><pre class="source lang-java linenums">package net.stoerr.ai.aigenpipeline.framework.task;

import static java.util.Objects.requireNonNull;
import static net.stoerr.ai.aigenpipeline.framework.task.AIVersionMarker.shaHash;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import net.stoerr.ai.aigenpipeline.framework.chat.AIChatBuilder;

/**
 * We support the generation of files using an AI, specifically ChatGPT. A generation task can have several input files.
 * Some of them can be prompt files with task descriptions, and some of them source files to be processed. The output
 * of each task is one text file. A complex task can have several steps leading to several intermediate files.
 * &lt;p&gt;
 * Since ChatGPT is not particularily fast not free and the generation results have to be manually checked, this is
 * heavily cached.
 * Into each output file we write the versions of all the input files from which it was generated into a comment.
 * When the tasks are run, we compare the
 * versions of all the input files with the versions recorded in the comment, and only regenerate the output file if
 * the versions have changed. An input file can have a version comment that explicitly states the version, or we take the
 * an abbreviated SHA256 hash of the input file as version. It is possible to explicitly state the versions in
 * version comments in the input files to avoid regenerating all files if minor details e.g. in a prompt file are
 * changed - only when the prompt file version comment is changed everything is regenerated.
 * &lt;p&gt;
 * A version comment can e.g. look like this:
 * &lt;p&gt;
 * // AIGenVersion(ourversion, inputfile1@version1, inputfile2@version2, ...)
 * &lt;p&gt;
 * where ourversion and version1 and version2 are hashes. ourversion is the hash of the original output of the AI.
 * The comment syntax (in this case //) is ignored - we just look for the AIGenVersion via regex.
 * &lt;p&gt;
 * Normally the intermediate and final results should be checked in with Git. That ensures manual checks when
 * they are regenerated, and minimizes regeneration.
 */
<span class="nc" id="L50">public class AIGenerationTask implements Cloneable {</span>

<span class="nc" id="L52">    protected static final Logger LOG = Logger.getLogger(AIGenerationTask.class.getName());</span>

    /**
     * A marker that can be inserted by the AI when something is wrong / unclear. We will make sure the user
     * sees that by aborting.
     */
    public static final String FIXME = &quot;FIXME&quot;;

    /**
     * A pattern that matches the license header, which we want to remove to avoid clutter.
     */
<span class="nc" id="L63">    protected static final Pattern PATTERN_LICENCE =</span>
<span class="nc" id="L64">            Pattern.compile(&quot;\\A&lt;!--(?s).*?Copyright.*?Adobe.*?Licensed under.*?--&gt;&quot;);</span>


<span class="nc" id="L67">    protected List&lt;File&gt; inputFiles = new ArrayList&lt;&gt;();</span>
    protected File outputFile;

    /**
     * The actual prompt created from prompt files and parameters.
     */
    protected String prompt;
<span class="nc" id="L74">    protected List&lt;File&gt; promptFiles = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L75">    protected Map&lt;String, String&gt; placeholdersAndValues = new LinkedHashMap&lt;&gt;();</span>

    protected String systemMessage;
    protected File systemMessageFile;
    protected Integer maxTokens;
<span class="nc" id="L80">    protected RegenerationCheckStrategy regenerationCheckStrategy = RegenerationCheckStrategy.VERSIONMARKER;</span>
<span class="nc" id="L81">    protected WritingStrategy writingStrategy = WritingStrategy.WITHVERSION;</span>

    /**
     * Creates a deep copy of the task.
     */
    public AIGenerationTask copy() {
        try {
<span class="nc" id="L88">            AIGenerationTask copy = (AIGenerationTask) super.clone();</span>
<span class="nc" id="L89">            copy.inputFiles = new ArrayList&lt;&gt;(inputFiles);</span>
<span class="nc" id="L90">            return copy;</span>
<span class="nc" id="L91">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L92">            throw new IllegalStateException(&quot;Bug - impossible.&quot;, e);</span>
        }
    }

    public AIGenerationTask maxTokens(Integer maxTokens) {
<span class="nc" id="L97">        this.maxTokens = maxTokens;</span>
<span class="nc" id="L98">        return this;</span>
    }

    public AIGenerationTask addOptionalInputFile(@Nullable File file) {
<span class="nc bnc" id="L102" title="All 4 branches missed.">        if (file != null &amp;&amp; file.exists()) {</span>
<span class="nc" id="L103">            inputFiles.add(file);</span>
        } else {
<span class="nc" id="L105">            LOG.fine(() -&gt; &quot;Optional file not there: &quot; + file);</span>
        }
<span class="nc" id="L107">        return this;</span>
    }

    public AIGenerationTask addInputFiles(List&lt;File&gt; files) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (File file : files) {</span>
<span class="nc" id="L112">            addInputFile(file);</span>
<span class="nc" id="L113">        }</span>
<span class="nc" id="L114">        return this;</span>
    }

    public AIGenerationTask addInputFile(File file) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(&quot;File &quot; + file + &quot; does not exist&quot;);</span>
        }
<span class="nc" id="L121">        inputFiles.add(file);</span>
<span class="nc" id="L122">        return this;</span>
    }

    public AIGenerationTask setOutputFile(@Nonnull File file) {
<span class="nc" id="L126">        requireNonNull(file, &quot;File must not be null&quot;);</span>
<span class="nc" id="L127">        outputFile = file;</span>
<span class="nc" id="L128">        return this;</span>
    }

    /**
     * Sets the strategy to check whether the generation has to be run. Default is {@link RegenerationCheckStrategy#VERSIONMARKER}.
     */
    public AIGenerationTask setRegenerationCheckStrategy(RegenerationCheckStrategy strategy) {
<span class="nc" id="L135">        this.regenerationCheckStrategy = strategy;</span>
<span class="nc" id="L136">        return this;</span>
    }

    /**
     * Sets the strategy to deal with writing the output file. Default is {@link WritingStrategy#WITHVERSION}.
     */
    public AIGenerationTask setWritingStrategy(WritingStrategy strategy) {
<span class="nc" id="L143">        this.writingStrategy = strategy;</span>
<span class="nc" id="L144">        return this;</span>
    }

    public boolean hasToBeRun() throws IOException {
<span class="nc" id="L148">        List&lt;File&gt; allInputs = getAllInputFiles();</span>
<span class="nc" id="L149">        List&lt;String&gt; additionalMarkers = getAdditionalMarkers();</span>
<span class="nc" id="L150">        List&lt;String&gt; inputVersions = AIVersionMarker.calculateInputMarkers(allInputs, additionalMarkers);</span>
<span class="nc" id="L151">        return regenerationCheckStrategy.needsRegeneration(outputFile, allInputs, writingStrategy, inputVersions);</span>
    }

    protected List&lt;String&gt; getAdditionalMarkers() {
<span class="nc" id="L155">        List&lt;String&gt; additionalMarkers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (!placeholdersAndValues.isEmpty()) {</span>
<span class="nc" id="L157">            additionalMarkers.add(&quot;parms-&quot; + shaHash(placeholdersAndValues.toString()));</span>
        }
<span class="nc" id="L159">        return additionalMarkers;</span>
    }

    protected List&lt;File&gt; getAllInputFiles() {
<span class="nc" id="L163">        List&lt;File&gt; allInputs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (systemMessageFile != null) {</span>
<span class="nc" id="L165">            allInputs.add(systemMessageFile);</span>
        }
<span class="nc" id="L167">        promptFiles.stream()</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                .filter(f -&gt; !f.getAbsolutePath().equals(outputFile.getAbsolutePath()))</span>
<span class="nc" id="L169">                .forEach(allInputs::add);</span>
<span class="nc" id="L170">        inputFiles.stream()</span>
                // don't introduce circular dependencies when updating an existing output file:
<span class="nc bnc" id="L172" title="All 2 branches missed.">                .filter(f -&gt; !f.getAbsolutePath().equals(outputFile.getAbsolutePath()))</span>
<span class="nc" id="L173">                .forEach(allInputs::add);</span>
<span class="nc" id="L174">        return allInputs;</span>
    }

    /**
     * The actual prompt to be executed. The prompt file content can contain placeholders that are replaced by the values given: placeholdersAndValues contain alternatingly placeholder names and values for them.
     *
     * @return this
     */
    public AIGenerationTask addPrompt(@Nonnull File promptFile, String... placeholdersAndValues) {
<span class="nc" id="L183">        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        for (int i = 0; i &lt; placeholdersAndValues.length; i += 2) {</span>
<span class="nc" id="L185">            map.put(placeholdersAndValues[i], placeholdersAndValues[i + 1]);</span>
        }
<span class="nc" id="L187">        return addPrompt(promptFile, map);</span>
    }

    /**
     * The actual prompt to be executed. The prompt file content can contain placeholders that are replaced by the values given.
     *
     * @return this
     */
    public AIGenerationTask addPrompt(@Nonnull File promptFile, Map&lt;String, String&gt; placeholdersAndValues) {
<span class="nc" id="L196">        String fileContent = getFileContent(promptFile);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (fileContent == null) {</span>
<span class="nc" id="L198">            throw new IllegalArgumentException(&quot;Could not read prompt file &quot; + promptFile);</span>
        }
<span class="nc" id="L200">        String newPrompt = unclutter(fileContent);</span>
<span class="nc" id="L201">        requireNonNull(newPrompt, &quot;Could not read prompt file &quot; + promptFile);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : placeholdersAndValues.entrySet()) {</span>
<span class="nc" id="L203">            newPrompt = newPrompt.replace(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L204">        }</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (this.prompt == null) {</span>
<span class="nc" id="L206">            this.prompt = newPrompt;</span>
        } else {
<span class="nc" id="L208">            this.prompt += &quot;\n\n&quot; + newPrompt;</span>
        }
<span class="nc" id="L210">        this.promptFiles.add(promptFile);</span>
<span class="nc" id="L211">        this.placeholdersAndValues.putAll(placeholdersAndValues);</span>
<span class="nc" id="L212">        return this;</span>
    }

    protected String getFileContent(@Nonnull File file) {
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L217">            return null;</span>
        }
        try {
<span class="nc" id="L220">            return Files.readString(file.toPath(), StandardCharsets.UTF_8);</span>
<span class="nc" id="L221">        } catch (IOException e) {</span>
<span class="nc" id="L222">            throw new IllegalArgumentException(&quot;Error reading file &quot; + file, e);</span>
        }
    }

    /* Remove some clutter that is not relevant and might even confuse the AI */
    protected static String unclutter(String content) {
<span class="nc" id="L228">        Matcher matcher = PATTERN_LICENCE.matcher(content);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (matcher.find()) {</span>
<span class="nc" id="L230">            content = matcher.replaceFirst(&quot;&quot;);</span>
        }
<span class="nc" id="L232">        matcher = AIVersionMarker.VERSION_MARKER_PATTERN.matcher(content);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (matcher.find()) {</span>
<span class="nc" id="L234">            content = matcher.replaceFirst(&quot;&quot;);</span>
        }
<span class="nc" id="L236">        return content;</span>
    }

    public AIGenerationTask setSystemMessage(@Nonnull File systemMessageFile) {
<span class="nc" id="L240">        String newSystemMessage = unclutter(getFileContent(systemMessageFile));</span>
<span class="nc" id="L241">        requireNonNull(newSystemMessage, &quot;Could not read system message file &quot; + systemMessageFile);</span>
<span class="nc" id="L242">        this.systemMessage = newSystemMessage;</span>
<span class="nc" id="L243">        this.systemMessageFile = systemMessageFile;</span>
<span class="nc" id="L244">        return this;</span>
    }

    protected String relativePath(@Nullable File file, @Nonnull File rootDirectory) {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (file == null) {</span>
<span class="nc" id="L249">            return null;</span>
        }
<span class="nc" id="L251">        requireNonNull(rootDirectory, &quot;Root directory must not be null&quot;);</span>
        String rootPath;
        try {
<span class="nc" id="L254">            rootPath = rootDirectory.getAbsoluteFile().getCanonicalFile().getAbsolutePath();</span>
<span class="nc" id="L255">            String filePath = file.getAbsoluteFile().getCanonicalFile().getAbsolutePath();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (!filePath.startsWith(rootPath)) {</span>
<span class="nc" id="L257">                throw new IllegalArgumentException(&quot;File &quot; + file + &quot; is not in root directory &quot; + rootDirectory);</span>
            }
<span class="nc" id="L259">            return filePath.substring(rootPath.length() + 1);</span>
<span class="nc" id="L260">        } catch (IOException e) {</span>
<span class="nc" id="L261">            throw new IllegalArgumentException(&quot;Error getting canonical path for &quot; + rootDirectory + &quot; or &quot; + file, e);</span>
        }
    }

    /**
     * Execute the task if necessary. If the output file is already there and up to date, nothing is done.
     */
    public AIGenerationTask execute(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory) throws IOException {
<span class="nc" id="L269">        String outputRelPath = relativePath(this.outputFile, rootDirectory);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (!hasToBeRun()) {</span>
<span class="nc" id="L271">            LOG.info(() -&gt; &quot;Task does not have to be run for: &quot; + outputRelPath);</span>
<span class="nc" id="L272">            return this;</span>
        }
<span class="nc" id="L274">        AIChatBuilder chat = makeChatBuilder(chatBuilderFactory, rootDirectory, outputRelPath);</span>
<span class="nc" id="L275">        String result = chat.execute();</span>
<span class="nc" id="L276">        LOG.fine(() -&gt; &quot;Result for task execution for: &quot; + outputRelPath + &quot;\n&quot; + result);</span>
<span class="nc" id="L277">        String outputVersion = shaHash(result);</span>

<span class="nc" id="L279">        List&lt;String&gt; allInputMarkers = AIVersionMarker.calculateInputMarkers(getAllInputFiles(), getAdditionalMarkers());</span>
<span class="nc" id="L280">        String versionComment = new AIVersionMarker(outputVersion, allInputMarkers).toString();</span>

<span class="nc" id="L282">        writingStrategy.write(outputFile, result, versionComment);</span>

        // We check that after writing since that likely makes it easier to check.
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (result.contains(FIXME)) {</span>
<span class="nc" id="L286">            throw new IllegalStateException(&quot;AI returned FIXME for &quot; + outputRelPath + &quot; :\n&quot; + result);</span>
        }
<span class="nc" id="L288">        return this;</span>
    }

    /**
     * For debugging purposes: returns the JSON that would be sent to the AI.
     */
    public String toJson(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory) {
<span class="nc" id="L295">        String outputRelPath = relativePath(this.outputFile, rootDirectory);</span>
<span class="nc" id="L296">        return makeChatBuilder(chatBuilderFactory, rootDirectory, outputRelPath).toJson();</span>
    }

    @Nonnull
    protected AIChatBuilder makeChatBuilder(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory, String outputRelPath) {
<span class="nc" id="L301">        requireNonNull(outputFile, &quot;No writeable output file given! &quot; + outputFile);</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (null != outputFile.getParentFile() &amp;&amp; !outputFile.getParentFile().isDirectory()) {</span>
<span class="nc" id="L303">            outputFile.getParentFile().mkdirs();</span>
        }
<span class="nc bnc" id="L305" title="All 4 branches missed.">        if (outputFile.exists() &amp;&amp; !outputFile.canWrite()) {</span>
<span class="nc" id="L306">            throw new IllegalArgumentException(&quot;No writeable output file given! &quot; + outputFile);</span>
        }
<span class="nc bnc" id="L308" title="All 4 branches missed.">        if (prompt == null || prompt.isBlank()) {</span>
<span class="nc" id="L309">            throw new IllegalArgumentException(&quot;No prompt given!&quot;);</span>
        }
<span class="nc" id="L311">        AIChatBuilder chat = chatBuilderFactory.get();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (maxTokens != null) {</span>
<span class="nc" id="L313">            chat.maxTokens(maxTokens);</span>
        }
<span class="nc bnc" id="L315" title="All 4 branches missed.">        if (systemMessage != null &amp;&amp; !systemMessage.isBlank()) {</span>
<span class="nc" id="L316">            chat.systemMsg(systemMessage);</span>
        } else {
<span class="nc" id="L318">            try (InputStream defaultprompt = AIGenerationTask.class.getResourceAsStream(&quot;/defaultsystemprompt.txt&quot;)) {</span>
<span class="nc" id="L319">                String defaultSysPrompt = new String(requireNonNull(defaultprompt).readAllBytes(), StandardCharsets.UTF_8);</span>
<span class="nc" id="L320">                chat.systemMsg(defaultSysPrompt);</span>
<span class="nc" id="L321">            } catch (IOException e) {</span>
<span class="nc" id="L322">                throw new IllegalStateException(&quot;Error reading default system message&quot;, e);</span>
<span class="nc" id="L323">            }</span>
        }
<span class="nc" id="L325">        inputFiles.forEach(file -&gt; {</span>
            // &quot;Put it into the AI's mouth&quot; pattern https://www.stoerr.net/blog/aimouth
<span class="nc" id="L327">            chat.userMsg(&quot;Retrieve the content of the input file &quot; + relativePath(file, rootDirectory));</span>
<span class="nc" id="L328">            chat.assistantMsg(unclutter(getFileContent(file)));</span>
<span class="nc" id="L329">        });</span>
<span class="nc" id="L330">        chat.userMsg(prompt);</span>
<span class="nc" id="L331">        LOG.fine(() -&gt; &quot;Executing chat for: &quot; + outputRelPath + &quot;\n&quot; + chat.toJson());</span>
<span class="nc" id="L332">        return chat;</span>
    }

    /**
     * Ask a question about the previous task execution. We assume it was previously run ({@link #hasToBeRun()} == false),
     * add the result of the previous execution to the chat, and ask the AI the given question about it.
     * This can be used e.g. to see why the AI did something, or in the process of improving the prompt, etc.
     *
     * @return the answer of the AI - not written to a file!
     */
    public String explain(@Nonnull Supplier&lt;AIChatBuilder&gt; chatBuilderFactory, @Nonnull File rootDirectory, @Nonnull String question) throws IOException {
<span class="nc" id="L343">        String outputRelPath = relativePath(this.outputFile, rootDirectory);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (hasToBeRun()) { // that's not strictly necessary, but if not that's a likely mistake</span>
<span class="nc" id="L345">            throw new IllegalStateException(&quot;Task has to be already run for: &quot; + outputRelPath);</span>
        }
<span class="nc" id="L347">        AIChatBuilder chat = makeChatBuilder(chatBuilderFactory, rootDirectory, outputRelPath);</span>
<span class="nc" id="L348">        String previousOutput = unclutter(getFileContent(outputFile));</span>
<span class="nc" id="L349">        requireNonNull(previousOutput, &quot;Could not read any content from file &quot; + outputFile);</span>
<span class="nc" id="L350">        chat.assistantMsg(previousOutput);</span>
<span class="nc" id="L351">        chat.userMsg(question);</span>
<span class="nc" id="L352">        String result = chat.execute();</span>
<span class="nc" id="L353">        LOG.info(() -&gt; &quot;Explanation result for &quot; + outputRelPath + &quot; with question &quot; + question + &quot; is:\n&quot; + result);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (result.contains(FIXME)) {</span>
<span class="nc" id="L355">            throw new IllegalStateException(&quot;AI returned FIXME for &quot; + outputRelPath + &quot; :\n&quot; + result);</span>
        }
<span class="nc" id="L357">        return result;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L362">        return &quot;AIGenerationTask{&quot; + &quot;inputFiles=&quot; + inputFiles +</span>
                &quot;, outputFile=&quot; + outputFile +
                &quot;, systemMessageFile=&quot; + systemMessageFile +
                &quot;, systemMessage='&quot; + systemMessage + '\'' +
                &quot;, promptFiles=&quot; + promptFiles +
                &quot;, placeholdersAndValues=&quot; + placeholdersAndValues +
                &quot;, prompt='&quot; + prompt + '\'' +
                '}';
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>